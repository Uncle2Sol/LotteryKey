<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>生成早期比特币钱包密钥</title>
    <!-- 使用国内 CDN -->
    <script src="https://cdn.staticfile.org/elliptic/6.5.4/elliptic.min.js"></script>
    <script src="https://cdn.staticfile.org/crypto-js/4.1.1/crypto-js.min.js"></script>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
            color: #333;
        }

        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 30px;
        }

        .container {
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .button-group {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        button {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        #generateBtn {
            background-color: #3498db;
            color: white;
        }

        #generateUncompressedBtn {
            background-color: #2ecc71;
            color: white;
        }

        #startBtn {
            background-color: #e74c3c;
            color: white;
        }

        #stopBtn {
            background-color: #95a5a6;
            color: white;
        }

        button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        .result {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
        }

        .result p {
            margin: 10px 0;
            word-break: break-all;
        }

        .status {
            margin: 20px 0;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 5px;
            border-left: 4px solid #3498db;
        }

        .found {
            color: #27ae60;
            font-weight: bold;
        }

        .error {
            color: #e74c3c;
            padding: 10px;
            background-color: #fde8e8;
            border-radius: 5px;
            margin: 10px 0;
        }

        .debug {
            color: #7f8c8d;
            font-size: 0.9em;
            margin-top: 20px;
        }

        .target-address {
            margin: 20px 0;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 5px;
        }

        .target-address input {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
            margin-top: 5px;
        }

        .target-address label {
            font-weight: bold;
            color: #2c3e50;
        }

        .balance {
            margin: 10px 0;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 5px;
            border-left: 4px solid #f1c40f;
        }

        .balance.positive {
            border-left-color: #2ecc71;
        }

        .balance.zero {
            border-left-color: #e74c3c;
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-left: 10px;
            vertical-align: middle;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .check-balance-btn {
            background-color: #f1c40f;
            color: #2c3e50;
            margin-left: 10px;
        }

        .check-balance-btn:hover:not(:disabled) {
            background-color: #f39c12;
        }

        .address-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 10px 0;
        }

        .address-row span {
            flex: 1;
            word-break: break-all;
        }

        .check-balance-btn {
            background-color: #f1c40f;
            color: #2c3e50;
            white-space: nowrap;
        }

        .check-balance-btn:hover:not(:disabled) {
            background-color: #f39c12;
        }

        .balance-section {
            margin: 15px 0;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 5px;
        }

        .balance-section h3 {
            margin: 0 0 10px 0;
            color: #2c3e50;
            font-size: 1.1em;
        }

        .current-info {
            margin: 15px 0;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 5px;
            border-left: 4px solid #3498db;
        }

        .current-info p {
            margin: 5px 0;
            word-break: break-all;
        }

        .current-info .label {
            font-weight: bold;
            color: #2c3e50;
        }

        .current-info .value {
            color: #34495e;
            font-family: monospace;
        }

        .highlight {
            background-color: #fff3cd;
            padding: 2px 5px;
            border-radius: 3px;
        }

        .input-section {
            margin: 20px 0;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 5px;
        }

        .input-section h3 {
            margin: 0 0 10px 0;
            color: #2c3e50;
            font-size: 1.1em;
        }

        .input-group {
            display: flex;
            gap: 10px;
            margin: 10px 0;
        }

        .input-group input {
            flex: 1;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
        }

        .input-group button {
            white-space: nowrap;
        }

        .balance-query-section {
            margin: 20px 0;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 5px;
        }

        .balance-query-section h3 {
            margin: 0 0 10px 0;
            color: #2c3e50;
            font-size: 1.1em;
        }

        .balance-result {
            margin-top: 15px;
            padding: 15px;
            background-color: #fff;
            border-radius: 5px;
            border-left: 4px solid #3498db;
        }

        .balance-result.positive {
            border-left-color: #2ecc71;
        }

        .balance-result.zero {
            border-left-color: #e74c3c;
        }

        .balance-result p {
            margin: 5px 0;
        }

        .balance-result .label {
            font-weight: bold;
            color: #2c3e50;
        }

        .balance-result .value {
            color: #34495e;
        }

        .balance-result .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-left: 10px;
            vertical-align: middle;
        }

        .similar-addresses {
            margin: 20px 0;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 5px;
        }

        .similar-addresses h3 {
            margin: 0 0 10px 0;
            color: #2c3e50;
            font-size: 1.1em;
        }

        .similar-address-item {
            margin: 10px 0;
            padding: 10px;
            background-color: #fff;
            border-radius: 5px;
            border-left: 4px solid #3498db;
        }

        .similar-address-item p {
            margin: 5px 0;
            word-break: break-all;
        }

        .similar-address-item .similarity {
            font-weight: bold;
            color: #e74c3c;
        }

        .similar-address-item .private-key {
            color: #2c3e50;
            font-family: monospace;
        }

        .similar-address-item .address {
            color: #34495e;
        }

        .optimization-info {
            margin: 15px 0;
            padding: 15px;
            background-color: #fff;
            border-radius: 5px;
            border-left: 4px solid #2ecc71;
        }

        .optimization-info p {
            margin: 5px 0;
        }

        .optimization-info .label {
            font-weight: bold;
            color: #2c3e50;
        }

        .optimization-info .value {
            color: #34495e;
            font-family: monospace;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background-color: #f0f0f0;
            border-radius: 10px;
            margin: 10px 0;
            overflow: hidden;
        }

        .progress-bar-fill {
            height: 100%;
            background-color: #2ecc71;
            transition: width 0.3s ease;
        }

        .batch-results {
            margin-top: 20px;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 5px;
        }

        .batch-results h3 {
            margin: 0 0 10px 0;
            color: #2c3e50;
            font-size: 1.1em;
        }

        .batch-status {
            margin-bottom: 15px;
            padding: 15px;
            background-color: #fff;
            border-radius: 5px;
            border-left: 4px solid #3498db;
        }

        .batch-status p {
            margin: 5px 0;
            font-size: 1.1em;
        }

        .batch-status strong {
            color: #2c3e50;
        }

        .batch-status span {
            color: #e74c3c;
            font-weight: bold;
        }

        .batch-addresses {
            margin-top: 10px;
            padding: 10px;
            background-color: #fff;
            border-radius: 5px;
        }

        .batch-address-item {
            margin: 10px 0;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 5px;
            border-left: 4px solid #2ecc71;
        }

        .batch-address-item p {
            margin: 5px 0;
            word-break: break-all;
        }

        .batch-address-item .label {
            font-weight: bold;
            color: #2c3e50;
        }

        .batch-address-item .value {
            color: #34495e;
            font-family: monospace;
        }

        .api-results {
            margin-top: 10px;
        }
        
        .api-result {
            padding: 10px;
            margin: 5px 0;
            background-color: #f8f9fa;
            border-radius: 5px;
            border-left: 4px solid #3498db;
        }
        
        .api-result.best-result {
            background-color: #e8f4f8;
            border-left-color: #2ecc71;
        }
        
        .api-result p {
            margin: 5px 0;
        }
        
        .api-result .label {
            font-weight: bold;
            color: #2c3e50;
        }
        
        .api-result .value {
            color: #34495e;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>早期比特币钱包密钥生成器</h1>
        
        <div class="balance-query-section">
            <h3>查询地址余额</h3>
            <div class="input-group">
                <input type="text" id="balanceQueryInput" placeholder="输入比特币地址" />
                <button onclick="queryAddressBalance()" class="check-balance-btn" id="queryBalanceBtn">查询余额</button>
            </div>
            <div class="balance-result" id="balanceQueryResult" style="display: none;">
                <p><span class="label">地址：</span> <span class="value" id="queriedAddress">-</span></p>
                <p><span class="label">余额：</span> <span class="value" id="queriedBalance">-</span></p>
                <p><span class="label">交易数量：</span> <span class="value" id="queriedTxCount">-</span></p>
            </div>
        </div>

        <div class="input-section">
            <h3>通过私钥查询地址</h3>
            <div class="input-group">
                <input type="text" id="privateKeyInput" placeholder="输入WIF格式的私钥" />
                <button onclick="getAddressFromPrivateKey()" class="check-balance-btn">查询地址</button>
            </div>
        </div>

        <div class="target-address">
            <label for="targetAddress">目标比特币地址：</label>
            <input type="text" id="targetAddress" value="1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa" placeholder="输入目标比特币地址">
        </div>

        <div class="input-section">
            <h3>地址前缀设置</h3>
            <div class="input-group">
                <input type="text" id="addressPrefix" placeholder="输入期望的地址前缀（例如：1A1zP）" />
                <button onclick="setAddressPrefix()" class="check-balance-btn">设置前缀</button>
            </div>
            <div class="current-info">
                <p><span class="label">当前前缀：</span> <span class="value" id="currentPrefix">无</span></p>
            </div>
        </div>

        <div class="button-group">
            <button onclick="generateKeyPair()" id="generateBtn">生成密钥对</button>
            <button onclick="startGenerating()" id="startBtn">开始循环生成</button>
            <button onclick="stopGenerating()" id="stopBtn" disabled>停止生成</button>
            <button onclick="startBatchGeneration()" id="batchGenerateBtn">批量生成100个</button>
        </div>

        <div class="result">
            <p><strong>私钥 (WIF):</strong> <span id="privateKey"></span></p>
            
            <div class="balance-section">
                <h3>比特币地址</h3>
                <div class="address-row">
                    <span id="address"></span>
                    <button onclick="checkBalance(document.getElementById('address').textContent, 'address')" class="check-balance-btn" id="checkBalanceBtn">查询余额</button>
                </div>
                <div class="balance" id="balanceInfo">
                    <div class="api-results">
                        <div class="api-result">
                    <p><strong>地址余额：</strong> <span id="balance">未查询</span></p>
                    <p><strong>交易数量：</strong> <span id="txCount">未查询</span></p>
                            <p><strong>数据来源：</strong> <span id="balanceSource">-</span></p>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="batch-results">
            <h3>批量生成结果</h3>
            <div class="batch-status">
                <p><strong>生成进度：</strong> <span id="batchProgress">0/100</span></p>
                <p><strong>已找到余额大于0的地址：</strong> <span id="foundAddresses">0</span></p>
            </div>
            <div class="batch-addresses" id="batchAddressesList">
                <!-- 批量生成的地址将在这里显示 -->
            </div>
        </div>

        <div class="status">
            <p><strong>生成状态：</strong> <span id="status">未开始</span></p>
            <p><strong>尝试次数：</strong> <span id="attempts">0</span></p>
            <div class="current-info">
                <p><span class="label">当前私钥 (WIF):</span> <span class="value" id="currentPrivateKey">-</span></p>
                <p><span class="label">当前地址:</span> <span class="value" id="currentAddress">-</span></p>
            </div>
        </div>

        <div class="similar-addresses">
            <h3>相似地址统计 (相似度 > 50%)</h3>
            <div class="similar-addresses-list" id="similarAddressesList">
                <!-- 相似地址将在这里动态添加 -->
            </div>
        </div>

        <p id="error" class="error"></p>
        <p id="debug" class="debug"></p>
    </div>

    <script>
        // Base58 编码实现
        const ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
        
        function base58Encode(bytes) {
            let num = BigInt('0x' + Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join(''));
            let str = '';
            while (num > 0) {
                str = ALPHABET[Number(num % BigInt(58))] + str;
                num = num / BigInt(58);
            }
            // 处理前导零
            for (let i = 0; i < bytes.length && bytes[i] === 0; i++) {
                str = '1' + str;
            }
            return str;
        }

        // 将 CryptoJS WordArray 转换为 Uint8Array
        function wordArrayToUint8Array(wordArray) {
            const words = wordArray.words;
            const sigBytes = wordArray.sigBytes;
            const u8 = new Uint8Array(sigBytes);
            
            for (let i = 0; i < sigBytes; i++) {
                u8[i] = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
            }
            
            return u8;
        }

        // 计算 SHA256 哈希
        function sha256(data) {
            return CryptoJS.SHA256(data).toString(CryptoJS.enc.Hex);
        }

        // 生成 WIF 格式的私钥
        function generateWIF(privateKeyHex, compressed = false) {
            try {
                // 1. 添加版本号 (0x80 for mainnet)
                const version = new Uint8Array([0x80]);
                
                // 2. 添加私钥数据
                const privateKeyBytes = new Uint8Array(32);
                for (let i = 0; i < 32; i++) {
                    privateKeyBytes[i] = parseInt(privateKeyHex.substr(i * 2, 2), 16);
                }
                
                // 3. 添加压缩标志 (如果需要)
                const data = compressed 
                    ? new Uint8Array([...version, ...privateKeyBytes, 0x01])
                    : new Uint8Array([...version, ...privateKeyBytes]);
                
                // 4. 计算校验和 (前4个字节的SHA256(SHA256(data)))
                const firstSHA = CryptoJS.SHA256(CryptoJS.lib.WordArray.create(data));
                const secondSHA = CryptoJS.SHA256(firstSHA);
                const checksum = wordArrayToUint8Array(secondSHA).slice(0, 4);
                
                // 5. 组合最终数据
                const finalData = new Uint8Array([...data, ...checksum]);
                
                // 6. Base58 编码
                const wif = base58Encode(finalData);
                
                // 7. 验证生成的 WIF
                if (!/^[5KL][1-9A-HJ-NP-Za-km-z]{50,51}$/.test(wif)) {
                    console.error('生成的 WIF 格式无效:', wif);
                    return null;
                }
                
                return wif;
            } catch (error) {
                console.error('生成 WIF 时出错:', error);
                return null;
            }
        }

        // 生成比特币地址
        function generateAddress(publicKeyHex, compressed = false) {
            // 1. 计算 SHA256
            const sha256Hash = CryptoJS.SHA256(CryptoJS.enc.Hex.parse(publicKeyHex));
            
            // 2. 计算 RIPEMD160
            const ripemd160Hash = CryptoJS.RIPEMD160(sha256Hash);
            
            // 3. 添加版本号 (0x00 for mainnet)
            const version = new Uint8Array([0x00]);
            const hash160Bytes = wordArrayToUint8Array(ripemd160Hash);
            
            // 4. 组合数据
            const data = new Uint8Array([...version, ...hash160Bytes]);
            
            // 5. 计算校验和 (前4个字节的SHA256(SHA256(data)))
            const firstSHA = CryptoJS.SHA256(CryptoJS.lib.WordArray.create(data));
            const secondSHA = CryptoJS.SHA256(firstSHA);
            const checksum = wordArrayToUint8Array(secondSHA).slice(0, 4);
            
            // 6. 组合最终数据
            const finalData = new Uint8Array([...data, ...checksum]);
            
            // 7. Base58 编码
            return base58Encode(finalData);
        }

        // 检查脚本加载状态
        function checkScriptLoaded(src) {
            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = src;
                script.onload = () => resolve();
                script.onerror = () => reject(new Error(`Failed to load ${src}`));
                document.head.appendChild(script);
            });
        }

        // 调试信息
        function updateDebugInfo() {
            const debug = document.getElementById('debug');
            debug.innerHTML = `
                加载状态：<br>
                elliptic: ${typeof elliptic !== 'undefined' ? '已加载' : '未加载'}<br>
                CryptoJS: ${typeof CryptoJS !== 'undefined' ? '已加载' : '未加载'}<br>
            `;
        }

        // 等待所有依赖加载完成
        window.addEventListener('load', async function() {
            try {
                // 尝试重新加载库
                await Promise.all([
                    checkScriptLoaded('https://cdn.staticfile.org/elliptic/6.5.4/elliptic.min.js'),
                    checkScriptLoaded('https://cdn.staticfile.org/crypto-js/4.1.1/crypto-js.min.js')
                ]);
                
                updateDebugInfo();
                
                // 检查所有必需的依赖是否都已加载
                if (typeof elliptic === 'undefined') {
                    throw new Error('elliptic 未正确加载');
                } else if (typeof CryptoJS === 'undefined') {
                    throw new Error('CryptoJS 未正确加载');
                }
                
                document.getElementById('error').textContent = '';
                document.getElementById('generateBtn').disabled = false;
            } catch (error) {
                console.error('加载库时出错:', error);
                document.getElementById('error').textContent = '错误：' + error.message;
                document.getElementById('generateBtn').disabled = true;
            }
        });

        // 添加前缀模式相关变量
        let currentPrefix = '';
        let prefixMode = false;

        // 设置地址前缀
        function setAddressPrefix() {
            const prefix = document.getElementById('addressPrefix').value.trim();
            if (prefix) {
                currentPrefix = prefix;
                prefixMode = true;
                document.getElementById('currentPrefix').textContent = prefix;
                document.getElementById('error').textContent = '';
            } else {
                currentPrefix = '';
                prefixMode = false;
                document.getElementById('currentPrefix').textContent = '无';
                document.getElementById('error').textContent = '请输入有效的前缀';
            }
        }

        // 检查地址是否匹配前缀
        function checkAddressPrefix(address) {
            if (!prefixMode) return true;
            return address.startsWith(currentPrefix);
        }

        // 修改生成密钥对函数
        function generateKeyPair() {
            try {
                // 创建 secp256k1 曲线实例
                const ec = new elliptic.ec('secp256k1');
                
                let address;
                let privateKeyWIF;
                let attempts = 0;
                const maxAttempts = 100000; // 增加最大尝试次数到10万次

                // 如果启用了前缀模式，循环生成直到匹配
                do {
                    // 生成随机密钥对
                    const keyPair = ec.genKeyPair();
                    
                    // 获取私钥（十六进制格式）
                    const privateKeyHex = keyPair.getPrivate('hex');
                    
                    // 获取未压缩公钥
                    const publicKeyUncompressed = keyPair.getPublic(false, 'hex');
                    
                    // 生成地址
                    address = generateAddress(publicKeyUncompressed, false);
                    
                    // 生成对应的 WIF 格式私钥
                    privateKeyWIF = generateWIF(privateKeyHex, false);
                    
                    attempts++;
                    
                    // 每1000次尝试显示一次进度
                    if (attempts % 1000 === 0) {
                        document.getElementById('status').textContent = `正在尝试生成匹配前缀的地址... (已尝试 ${attempts} 次)`;
                    }
                    
                    // 如果超过最大尝试次数，显示错误并退出
                    if (attempts > maxAttempts) {
                        throw new Error(`无法在 ${maxAttempts} 次尝试内生成匹配前缀 "${currentPrefix}" 的地址，请尝试较短的前缀或继续尝试`);
                    }
                } while (prefixMode && !checkAddressPrefix(address));

                // 显示结果
                document.getElementById('privateKey').textContent = privateKeyWIF;
                document.getElementById('address').textContent = address;
                document.getElementById('error').textContent = '';
                document.getElementById('status').textContent = `成功生成匹配前缀的地址！(尝试次数: ${attempts})`;
                
                // 重置余额显示
                resetBalanceDisplay('address');
            } catch (error) {
                console.error('生成密钥对时出错:', error);
                document.getElementById('error').textContent = '生成密钥对时出错: ' + error.message;
                document.getElementById('status').textContent = '生成失败';
            }
        }

        // 修改重置余额显示函数
        function resetBalanceDisplay(type) {
            const balanceInfo = document.getElementById('balanceInfo');
            balanceInfo.innerHTML = `
                <div class="api-results">
                    <div class="api-result">
                        <p><strong>地址余额：</strong> <span id="balance">未查询</span></p>
                        <p><strong>交易数量：</strong> <span id="txCount">未查询</span></p>
                        <p><strong>数据来源：</strong> <span id="balanceSource">-</span></p>
                    </div>
                </div>
            `;
            balanceInfo.className = 'balance';
        }

        let isGenerating = false;
        let attempts = 0;
        let similarAddresses = [];
        const SIMILARITY_THRESHOLD = 0.5; // 50% 相似度阈值
        let optimizationData = {
            prefixPatterns: new Map(), // 存储地址前缀模式
            suffixPatterns: new Map(), // 存储地址后缀模式
            bestSimilarity: 0,         // 最佳相似度
            bestPatterns: {            // 最佳模式
                prefix: '',
                suffix: ''
            }
        };

        function updateStatus(message, isFound = false) {
            const status = document.getElementById('status');
            status.textContent = message;
            if (isFound) {
                status.className = 'found';
            }
        }

        function startGenerating() {
            const targetAddress = getTargetAddress();
            if (!targetAddress) {
                document.getElementById('error').textContent = '请输入目标比特币地址';
                return;
            }

            isGenerating = true;
            attempts = 0;
            document.getElementById('startBtn').disabled = true;
            document.getElementById('stopBtn').disabled = false;
            updateStatus('正在生成...');
            
            // 重置当前信息显示
            document.getElementById('currentPrivateKey').textContent = '-';
            document.getElementById('currentAddress').textContent = '-';
            
            // 重置相似地址数组和优化数据
            similarAddresses = [];
            optimizationData = {
                prefixPatterns: new Map(),
                suffixPatterns: new Map(),
                bestSimilarity: 0,
                bestPatterns: {
                    prefix: '',
                    suffix: ''
                }
            };
            updateSimilarAddressesList();
            
            generateUntilMatch();
        }

        async function generateUntilMatch() {
            const ec = new elliptic.ec('secp256k1');
            const targetAddress = getTargetAddress();
            const genesisAddress = '1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa';
            
            while (isGenerating) {
                try {
                    // 使用优化后的私钥生成方法
                    const privateKeyHex = generateOptimizedPrivateKey();

                    // 创建密钥对
                    const keyPair = ec.keyFromPrivate(privateKeyHex, 'hex');
                    
                    // 获取未压缩公钥
                    const publicKeyUncompressed = keyPair.getPublic(false, 'hex');
                    
                    // 生成地址
                    const address = generateAddress(publicKeyUncompressed, false);
                    
                    attempts++;
                    document.getElementById('attempts').textContent = attempts;
                    
                    // 如果启用了前缀模式且地址不匹配前缀，则跳过
                    if (prefixMode && !checkAddressPrefix(address)) {
                        // 每1000次尝试显示一次进度
                        if (attempts % 1000 === 0) {
                            updateStatus(`正在尝试生成匹配前缀的地址... (已尝试 ${attempts} 次)`);
                        }
                        continue;
                    }
                    
                    // 生成 WIF 格式私钥
                    const privateKeyWIF = generateWIF(privateKeyHex, false);
                    if (!privateKeyWIF) {
                        continue;
                    }
                    
                    // 更新当前信息显示
                    document.getElementById('currentPrivateKey').textContent = privateKeyWIF;
                    document.getElementById('currentAddress').textContent = address;

                    // 计算与目标地址的相似度
                    const similarity = calculateSimilarity(address, targetAddress);
                    
                    // 如果相似度超过阈值，添加到相似地址列表
                    if (similarity > SIMILARITY_THRESHOLD) {
                        addSimilarAddress(privateKeyWIF, address, similarity);
                    }

                    // 每生成10个地址更新一次状态
                    if (attempts % 10 === 0) {
                        updateStatus(`已尝试 ${attempts} 次...`);
                    }

                    // 使用 setTimeout 让浏览器有机会更新UI
                    await new Promise(resolve => setTimeout(resolve, 0));
                } catch (error) {
                    console.error('生成密钥对时出错:', error);
                    document.getElementById('error').textContent = '生成密钥对时出错: ' + error.message;
                    continue;
                }
            }
        }

        // 分析地址模式
        function analyzeAddressPattern(address, similarity) {
            const genesisAddress = '1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa';
            
            // 分析前缀模式
            for (let i = 0; i < address.length; i++) {
                if (address[i] === genesisAddress[i]) {
                    const prefix = address.substring(0, i + 1);
                    const count = optimizationData.prefixPatterns.get(prefix) || 0;
                    optimizationData.prefixPatterns.set(prefix, count + 1);
                } else {
                    break;
                }
            }

            // 分析后缀模式
            for (let i = address.length - 1; i >= 0; i--) {
                if (address[i] === genesisAddress[i]) {
                    const suffix = address.substring(i);
                    const count = optimizationData.suffixPatterns.get(suffix) || 0;
                    optimizationData.suffixPatterns.set(suffix, count + 1);
                } else {
                    break;
                }
            }

            // 更新最佳模式
            if (similarity > optimizationData.bestSimilarity) {
                optimizationData.bestSimilarity = similarity;
                optimizationData.bestPatterns = {
                    prefix: Array.from(optimizationData.prefixPatterns.entries())
                        .sort((a, b) => b[1] - a[1])[0]?.[0] || '',
                    suffix: Array.from(optimizationData.suffixPatterns.entries())
                        .sort((a, b) => b[1] - a[1])[0]?.[0] || ''
                };
            }
        }

        // 优化私钥生成
        function generateOptimizedPrivateKey() {
            // 使用更安全的随机数生成方法
            const randomBytes = new Uint8Array(32);
            crypto.getRandomValues(randomBytes);
            
            // 如果还没有足够的优化数据，使用完全随机生成
            if (optimizationData.bestSimilarity < 0.6) {
                return Array.from(randomBytes)
                    .map(b => b.toString(16).padStart(2, '0'))
                    .join('');
            }

            // 使用优化策略生成私钥
            let privateKeyHex = '';
            
            // 生成完全随机的私钥
            for (let i = 0; i < 32; i++) {
                privateKeyHex += randomBytes[i].toString(16).padStart(2, '0');
            }

            // 确保私钥在有效范围内
            const privateKeyNum = BigInt('0x' + privateKeyHex);
            const n = BigInt('0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141');
            
            if (privateKeyNum >= n) {
                // 如果超出范围，重新生成
                return generateOptimizedPrivateKey();
            }

            return privateKeyHex;
        }

        // 添加相似地址到列表
        function addSimilarAddress(privateKey, address, similarity) {
            // 检查是否已存在相同地址
            if (similarAddresses.some(item => item.address === address)) {
                return;
            }

            // 添加到数组
            similarAddresses.push({
                privateKey,
                address,
                similarity
            });

            // 按相似度排序
            similarAddresses.sort((a, b) => b.similarity - a.similarity);

            // 分析地址模式
            analyzeAddressPattern(address, similarity);

            // 更新显示
            updateSimilarAddressesList();
        }

        // 更新相似地址列表显示
        function updateSimilarAddressesList() {
            const list = document.getElementById('similarAddressesList');
            list.innerHTML = '';

            similarAddresses.forEach(item => {
                const div = document.createElement('div');
                div.className = 'similar-address-item';
                div.innerHTML = `
                    <p><span class="similarity">相似度: ${(item.similarity * 100).toFixed(2)}%</span></p>
                    <p><span class="label">私钥 (WIF):</span> <span class="private-key">${item.privateKey}</span></p>
                    <p><span class="label">地址:</span> <span class="address">${item.address}</span></p>
                `;
                list.appendChild(div);
            });

            // 显示优化信息
            const optimizationInfo = document.createElement('div');
            optimizationInfo.className = 'optimization-info';
            
            // 计算优化进度
            const optimizationProgress = Math.min(100, (optimizationData.bestSimilarity / 0.6) * 100);
            
            optimizationInfo.innerHTML = `
                <p><strong>优化信息：</strong></p>
                <p><span class="label">最佳相似度:</span> <span class="value">${(optimizationData.bestSimilarity * 100).toFixed(2)}%</span></p>
                <p><span class="label">最佳前缀模式:</span> <span class="value">${optimizationData.bestPatterns.prefix || '暂无'}</span></p>
                <p><span class="label">最佳后缀模式:</span> <span class="value">${optimizationData.bestPatterns.suffix || '暂无'}</span></p>
                <p><span class="label">优化进度:</span></p>
                <div class="progress-bar">
                    <div class="progress-bar-fill" style="width: ${optimizationProgress}%"></div>
                </div>
                <p><span class="label">已收集模式数:</span> <span class="value">${optimizationData.prefixPatterns.size + optimizationData.suffixPatterns.size}</span></p>
                <p><span class="label">当前生成策略:</span> <span class="value">${optimizationData.bestSimilarity >= 0.6 ? '优化模式' : '完全随机'}</span></p>
            `;
            list.appendChild(optimizationInfo);
        }

        function getTargetAddress() {
            return document.getElementById('targetAddress').value.trim();
        }

        function updateAttempts() {
            document.getElementById('attempts').textContent = attempts;
        }

        function updateCurrentAddress(address) {
            document.getElementById('currentAddress').textContent = address;
        }

        function stopGenerating() {
            isGenerating = false;
            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            document.getElementById('batchGenerateBtn').disabled = false;
            updateStatus('已停止');
            
            // 清除当前信息显示
            document.getElementById('currentPrivateKey').textContent = '-';
            document.getElementById('currentAddress').textContent = '-';
        }

        // 添加多个可靠的 API 源
        const bitcoinAPIs = [
            {
                name: 'BlockCypher',
                url: (address) => `https://api.blockcypher.com/v1/btc/main/addrs/${address}/balance`,
                parseResponse: (data) => {
                    return {
                    balance: data.final_balance / 100000000,
                        txCount: data.n_tx,
                        source: 'BlockCypher'
                    };
                }
            },
            {
                name: 'Blockchair',
                url: (address) => `https://api.blockchair.com/bitcoin/dashboards/address/${address}`,
                parseResponse: (data) => {
                    const addressData = data.data[address];
                    return {
                        balance: addressData.total_received / 100000000, // 使用 total_received 而不是 balance
                        txCount: addressData.transaction_count,
                        source: 'Blockchair'
                    };
                }
            },
            {
                name: 'Mempool',
                url: (address) => `https://mempool.space/api/address/${address}/utxo`,
                parseResponse: (data) => {
                    let totalBalance = 0;
                    data.forEach(utxo => {
                        totalBalance += utxo.value;
                    });
                    return {
                        balance: totalBalance / 100000000,
                        txCount: data.length,
                        source: 'Mempool'
                    };
                }
            }
        ];

        // 添加 API 状态跟踪
        const apiStatus = {
            lastUsed: {},
            failures: {},
            cooldown: 5000, // 5秒冷却时间
            maxFailures: 3
        };

        // 获取下一个可用的 API
        function getNextApi() {
            const now = Date.now();
            let bestApi = null;
            let minFailures = Infinity;

            for (const api of bitcoinAPIs) {
                const lastUsed = apiStatus.lastUsed[api.name] || 0;
                const failures = apiStatus.failures[api.name] || 0;
                
                // 如果 API 在冷却中，跳过
                if (now - lastUsed < apiStatus.cooldown) {
                    continue;
                }
                
                // 如果失败次数过多，跳过
                if (failures >= apiStatus.maxFailures) {
                    continue;
                }
                
                // 选择失败次数最少的 API
                if (failures < minFailures) {
                    minFailures = failures;
                    bestApi = api;
                }
            }

            return bestApi || bitcoinAPIs[0]; // 如果没有可用的 API，返回第一个
        }

        // 记录 API 使用情况
        function recordApiUsage(apiName, success) {
            apiStatus.lastUsed[apiName] = Date.now();
            if (success) {
                apiStatus.failures[apiName] = 0;
            } else {
                apiStatus.failures[apiName] = (apiStatus.failures[apiName] || 0) + 1;
        }
        }

        async function queryAddressBalance() {
            const address = document.getElementById('balanceQueryInput').value.trim();
            if (!address) {
                document.getElementById('error').textContent = '请输入比特币地址';
                return;
            }

            const queryBalanceBtn = document.getElementById('queryBalanceBtn');
            const balanceResult = document.getElementById('balanceQueryResult');

            // 重置所有状态
            document.getElementById('error').textContent = '';
            balanceResult.style.display = 'none';
                queryBalanceBtn.disabled = true;
            
            try {
                balanceResult.style.display = 'block';
                let resultsHtml = '<div class="api-results">';
                let bestResult = null;

                // 尝试所有可用的 API
                for (const api of bitcoinAPIs) {
                    try {
                        console.log(`尝试使用 ${api.name} API 查询余额...`);
                        const response = await fetch(api.url(address));
                        
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        
                        const data = await response.json();
                        const result = api.parseResponse(data);
                        
                        if (result && typeof result.balance === 'number') {
                            recordApiUsage(api.name, true);
                            
                            // 更新最佳结果
                            if (!bestResult || result.balance > bestResult.balance) {
                                bestResult = result;
                            }
                            
                            resultsHtml += `
                                <div class="api-result ${result === bestResult ? 'best-result' : ''}">
                                    <p><span class="label">来源：</span> <span class="value">${result.source}</span></p>
                                    <p><span class="label">余额：</span> <span class="value">${result.balance.toFixed(8)} BTC</span></p>
                                    <p><span class="label">交易数：</span> <span class="value">${result.txCount}</span></p>
                                </div>
                            `;
                        }
                    } catch (error) {
                        console.error(`${api.name} API 查询失败:`, error);
                        recordApiUsage(api.name, false);
                    }
                }
                
                resultsHtml += '</div>';
                        
                if (bestResult) {
                    balanceResult.innerHTML = resultsHtml;
                    balanceResult.className = 'balance-result ' + (bestResult.balance > 0 ? 'positive' : 'zero');
                } else {
                    throw new Error('所有 API 查询均失败');
                }
            } catch (error) {
                console.error('查询余额时出错:', error);
                balanceResult.innerHTML = `
                    <div class="api-results">
                        <div class="api-result">
                            <p><span class="label">查询失败：</span> <span class="value">${error.message}</span></p>
                            <p><span class="label">提示：</span> <span class="value">请稍后重试</span></p>
                        </div>
                    </div>
                `;
                balanceResult.className = 'balance-result error';
            } finally {
                queryBalanceBtn.disabled = false;
            }
        }

        // 修改余额查询函数
        async function checkBalance(address, type) {
            if (!address) {
                document.getElementById('error').textContent = '请先生成地址';
                return null;
            }

            const balanceInfo = document.getElementById('balanceInfo');
            const balanceSpan = document.getElementById('balance');
            const txCountSpan = document.getElementById('txCount');
            const balanceSourceSpan = document.getElementById('balanceSource');
            const checkBalanceBtn = document.getElementById('checkBalanceBtn');
            
            // 重置所有状态
            document.getElementById('error').textContent = '';
            balanceInfo.className = 'balance';
                checkBalanceBtn.disabled = true;
            
            try {
                balanceSpan.innerHTML = '<span class="loading"></span> 查询中...';
                txCountSpan.innerHTML = '<span class="loading"></span> 查询中...';
                balanceSourceSpan.textContent = '查询中...';

                let bestResult = null;
                let allResults = [];
                
                // 尝试所有可用的 API
                for (const api of bitcoinAPIs) {
                    try {
                        console.log(`尝试使用 ${api.name} API 查询余额...`);
                        const response = await fetch(api.url(address));
                        
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        
                        const data = await response.json();
                        const result = api.parseResponse(data);
                        
                        if (result && typeof result.balance === 'number') {
                            recordApiUsage(api.name, true);
                            allResults.push(result);
                        
                            // 更新最佳结果
                            if (!bestResult || result.balance > bestResult.balance) {
                                bestResult = result;
                            }
                        }
                    } catch (error) {
                        console.error(`${api.name} API 查询失败:`, error);
                        recordApiUsage(api.name, false);
                    }
                }
                
                if (bestResult) {
                    // 更新余额显示
                    balanceSpan.textContent = `${bestResult.balance.toFixed(8)} BTC`;
                    txCountSpan.textContent = bestResult.txCount;
                    balanceSourceSpan.textContent = bestResult.source;
                    
                    // 更新样式
                    balanceInfo.className = 'balance ' + (bestResult.balance > 0 ? 'positive' : 'zero');
                    
                    // 如果有多个结果，显示所有结果
                    if (allResults.length > 1) {
                        let resultsHtml = '<div class="api-results">';
                        allResults.forEach(result => {
                            resultsHtml += `
                                <div class="api-result ${result === bestResult ? 'best-result' : ''}">
                                    <p><span class="label">来源：</span> <span class="value">${result.source}</span></p>
                                    <p><span class="label">余额：</span> <span class="value">${result.balance.toFixed(8)} BTC</span></p>
                                    <p><span class="label">交易数：</span> <span class="value">${result.txCount}</span></p>
                                </div>
                            `;
                        });
                        resultsHtml += '</div>';
                        balanceInfo.innerHTML = resultsHtml;
                        }
                    
                    return bestResult;
                } else {
                    throw new Error('所有 API 查询均失败');
                }
            } catch (error) {
                console.error('查询余额时出错:', error);
                balanceSpan.textContent = '查询失败';
                txCountSpan.textContent = '查询失败';
                balanceSourceSpan.textContent = '查询失败';
                balanceInfo.className = 'balance error';
                document.getElementById('error').textContent = '查询余额时出错: ' + error.message;
                return null;
            } finally {
                checkBalanceBtn.disabled = false;
            }
        }

        function startBatchGeneration() {
            const targetAddress = getTargetAddress();
            if (!targetAddress) {
                document.getElementById('error').textContent = '请输入目标比特币地址';
                return;
            }

            isGenerating = true;
            attempts = 0;
            document.getElementById('startBtn').disabled = true;
            document.getElementById('stopBtn').disabled = false;
            updateStatus('正在批量生成...');
            
            // 重置当前信息显示
            document.getElementById('currentPrivateKey').textContent = '-';
            document.getElementById('currentAddress').textContent = '-';
            
            // 重置相似地址数组和优化数据
            similarAddresses = [];
            optimizationData = {
                prefixPatterns: new Map(),
                suffixPatterns: new Map(),
                bestSimilarity: 0,
                bestPatterns: {
                    prefix: '',
                    suffix: ''
                }
            };
            updateSimilarAddressesList();
            
            generateBatchUntilMatch();
        }

        // 修改保存钱包信息到文件的函数
        function saveWalletToFile(walletInfo) {
            const timestamp = new Date().toLocaleString();
            const content = `时间: ${timestamp}\n地址: ${walletInfo.address}\n私钥(WIF): ${walletInfo.privateKey}\n余额: ${walletInfo.balance.toFixed(8)} BTC\n交易数量: ${walletInfo.txCount}\n\n`;
            
            // 创建 Blob 对象
            const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
            
            // 创建下载链接
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = 'found_wallets.txt';
            
            // 如果文件已存在，则追加内容
            const existingContent = localStorage.getItem('foundWallets') || '';
            localStorage.setItem('foundWallets', existingContent + content);
            
            // 触发下载
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        // 修改批量生成函数
        async function generateBatchUntilMatch() {
            const ec = new elliptic.ec('secp256k1');
            const targetAddress = getTargetAddress();
            const genesisAddress = '1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa';
            
            let foundAddresses = 0;
            const totalAddresses = 100;
            const addressesWithBalance = [];
            let attempts = 0;
            const maxAttempts = 1000000;
            const batchSize = 10;
            const queryTimeout = 5000;

            // 从 localStorage 恢复之前的数据
            const savedWallets = localStorage.getItem('foundWallets');
            if (savedWallets) {
                const wallets = savedWallets.split('\n\n').filter(w => w.trim());
                wallets.forEach(wallet => {
                    const lines = wallet.split('\n');
                    if (lines.length >= 4) {
                        const address = lines[1].split(': ')[1];
                        const privateKey = lines[2].split(': ')[1];
                        const balance = parseFloat(lines[3].split(': ')[1]);
                        const txCount = parseInt(lines[4].split(': ')[1]);
                        
                        if (balance > 0) {
                            addressesWithBalance.push({
                                address,
                                privateKey,
                                balance,
                                txCount
                            });
                            foundAddresses++;
                        }
                    }
                });
                
                document.getElementById('batchProgress').textContent = `${foundAddresses}/100`;
                document.getElementById('foundAddresses').textContent = foundAddresses;
                updateBatchAddressesList(addressesWithBalance);
            }

            // 添加进度条
            const progressBar = document.createElement('div');
            progressBar.className = 'progress-bar';
            progressBar.innerHTML = '<div class="progress-bar-fill" style="width: 0%"></div>';
            document.querySelector('.batch-status').appendChild(progressBar);

            // 更新状态显示函数
            function updateCurrentInfo(privateKey, address) {
                document.getElementById('currentPrivateKey').textContent = privateKey;
                document.getElementById('currentAddress').textContent = address;
                document.getElementById('attempts').textContent = attempts;
            }

            while (foundAddresses < totalAddresses && isGenerating) {
                try {
                    // 生成一批地址
                    const batchAddresses = [];
                    for (let i = 0; i < batchSize && foundAddresses + batchAddresses.length < totalAddresses; i++) {
                    const privateKeyHex = generateOptimizedPrivateKey();
                    const keyPair = ec.keyFromPrivate(privateKeyHex, 'hex');
                    const publicKeyUncompressed = keyPair.getPublic(false, 'hex');
                    const address = generateAddress(publicKeyUncompressed, false);
                        const privateKeyWIF = generateWIF(privateKeyHex, false);
                        
                        if (privateKeyWIF) {
                            batchAddresses.push({
                                address,
                                privateKey: privateKeyWIF
                            });
                            // 更新当前生成的信息
                            updateCurrentInfo(privateKeyWIF, address);
                        }
                        
                        attempts++;
                    }
                    
                    // 批量查询余额
                    const balancePromises = batchAddresses.map(async (wallet) => {
                        try {
                            const controller = new AbortController();
                            const timeoutId = setTimeout(() => controller.abort(), queryTimeout);
                    
                            // 更新状态显示正在查询
                            updateCurrentInfo(wallet.privateKey, wallet.address);
                            updateStatus(`正在查询地址 ${wallet.address} 的余额...`);
                            
                            const response = await fetch(bitcoinAPIs[0].url(wallet.address), {
                                signal: controller.signal
                            });
                            
                            clearTimeout(timeoutId);
                            
                            if (!response.ok) {
                                throw new Error(`HTTP error! status: ${response.status}`);
                            }
                            
                            const data = await response.json();
                            const result = bitcoinAPIs[0].parseResponse(data);
                            
                            if (result && result.balance > 0) {
                                return {
                                    ...wallet,
                                    balance: result.balance,
                                    txCount: result.txCount
                                };
                            }
                        } catch (error) {
                            console.error(`查询地址 ${wallet.address} 余额失败:`, error);
                            updateStatus(`查询地址 ${wallet.address} 失败: ${error.message}`);
                        }
                        return null;
                    });

                    // 等待所有查询完成
                    const results = await Promise.all(balancePromises);
                    
                    // 处理有余额的结果
                    results.forEach(result => {
                        if (result) {
                            addressesWithBalance.push(result);
                        foundAddresses++;
                            saveWalletToFile(result);
                            // 更新状态显示找到有余额的地址
                            updateStatus(`找到有余额的地址: ${result.address} (${result.balance.toFixed(8)} BTC)`);
                        }
                    });
                        
                        // 更新进度显示
                    const progress = (foundAddresses / totalAddresses) * 100;
                    progressBar.querySelector('.progress-bar-fill').style.width = `${progress}%`;
                        document.getElementById('batchProgress').textContent = `${foundAddresses}/100`;
                        document.getElementById('foundAddresses').textContent = foundAddresses;
                        updateBatchAddressesList(addressesWithBalance);

                    // 更新状态
                        updateStatus(`已尝试 ${attempts} 次... 已找到 ${foundAddresses} 个余额大于0的地址`);

                    // 每批处理完后暂停一下，避免请求过于频繁
                    await new Promise(resolve => setTimeout(resolve, 1000));

                } catch (error) {
                    console.error('批量生成时出错:', error);
                    document.getElementById('error').textContent = '批量生成时出错: ' + error.message;
                    continue;
                }
            }

            // 移除进度条
            progressBar.remove();

            // 停止生成
            stopGenerating();
            
            // 显示最终结果
            if (addressesWithBalance.length > 0) {
                updateStatus(`批量生成完成。共找到 ${addressesWithBalance.length} 个余额大于0的地址。总尝试次数: ${attempts}`);
            } else {
                updateStatus(`批量生成完成。未找到余额大于0的地址。总尝试次数: ${attempts}`);
            }
        }

        // 修改批量地址列表更新函数
        function updateBatchAddressesList(addresses) {
            const list = document.getElementById('batchAddressesList');
            list.innerHTML = addresses.map(item => `
                <div class="batch-address-item">
                    <p><strong>地址：</strong> ${item.address}</p>
                    <p><strong>私钥 (WIF)：</strong> ${item.privateKey}</p>
                    <p><strong>余额：</strong> ${item.balance.toFixed(8)} BTC</p>
                    <p><strong>交易数量：</strong> ${item.txCount}</p>
                    <p><strong>数据来源：</strong> BlockCypher</p>
                </div>
            `).join('');
        }

        // 从私钥获取地址
        async function getAddressFromPrivateKey() {
            const privateKeyWIF = document.getElementById('privateKeyInput').value.trim();
            if (!privateKeyWIF) {
                document.getElementById('error').textContent = '请输入私钥';
                return;
            }

            try {
                // 创建 secp256k1 曲线实例
                const ec = new elliptic.ec('secp256k1');
                
                // 从WIF格式私钥获取十六进制私钥
                const privateKeyHex = getPrivateKeyFromWIF(privateKeyWIF);
                if (!privateKeyHex) {
                    throw new Error('无效的WIF格式私钥');
                }

                // 验证私钥长度
                if (privateKeyHex.length !== 64) {
                    throw new Error('私钥长度不正确');
                }

                // 创建密钥对
                const keyPair = ec.keyFromPrivate(privateKeyHex, 'hex');
                
                // 获取未压缩公钥
                const publicKeyUncompressed = keyPair.getPublic(false, 'hex');
                
                // 生成地址
                const address = generateAddress(publicKeyUncompressed, false);

                // 显示结果
                document.getElementById('privateKey').textContent = privateKeyWIF;
                document.getElementById('address').textContent = address;
                document.getElementById('error').textContent = '';

                // 重置余额显示
                resetBalanceDisplay('address');

                // 添加调试信息
                console.log('私钥解析成功:', {
                    wif: privateKeyWIF,
                    hex: privateKeyHex,
                    address: address
                });
            } catch (error) {
                console.error('从私钥获取地址时出错:', error);
                document.getElementById('error').textContent = '从私钥获取地址时出错: ' + error.message;
            }
        }

        // 从WIF格式私钥获取十六进制私钥
        function getPrivateKeyFromWIF(wif) {
            try {
                // 1. 验证 WIF 格式
                if (!/^[5KL][1-9A-HJ-NP-Za-km-z]{50,51}$/.test(wif)) {
                    console.error('无效的 WIF 格式');
                    return null;
                }

                // 2. Base58解码
                const decoded = base58Decode(wif);
                if (!decoded) {
                    console.error('Base58解码失败');
                    return null;
                }

                // 3. 验证长度
                const expectedLength = wif.startsWith('5') ? 37 : 38; // 未压缩: 37, 压缩: 38
                if (decoded.length !== expectedLength) {
                    console.error('私钥长度不正确:', decoded.length);
                    return null;
                }

                // 4. 验证版本号（0x80）
                if (decoded[0] !== 0x80) {
                    console.error('无效的版本号:', decoded[0]);
                    return null;
                }

                // 5. 验证校验和
                const data = decoded.slice(0, -4);
                const checksum = decoded.slice(-4);
                const firstSHA = CryptoJS.SHA256(CryptoJS.lib.WordArray.create(data));
                const secondSHA = CryptoJS.SHA256(firstSHA);
                const calculatedChecksum = wordArrayToUint8Array(secondSHA).slice(0, 4);
                
                if (!arraysEqual(checksum, calculatedChecksum)) {
                    console.error('校验和验证失败');
                    return null;
                }

                // 6. 提取私钥（跳过版本号，取32字节）
                const privateKey = decoded.slice(1, 33);
                
                // 7. 转换为十六进制
                const hex = Array.from(privateKey)
                    .map(b => b.toString(16).padStart(2, '0'))
                    .join('');

                return hex;
            } catch (error) {
                console.error('解析WIF私钥时出错:', error);
                return null;
            }
        }

        // Base58解码
        function base58Decode(str) {
            try {
                let num = BigInt(0);
                for (let i = 0; i < str.length; i++) {
                    const char = str[i];
                    const value = ALPHABET.indexOf(char);
                    if (value === -1) {
                        console.error('无效的Base58字符:', char);
                        return null;
                    }
                    num = num * BigInt(58) + BigInt(value);
                }

                // 转换为字节数组
                const bytes = [];
                while (num > 0) {
                    bytes.unshift(Number(num % BigInt(256)));
                    num = num / BigInt(256);
                }

                // 处理前导1
                for (let i = 0; i < str.length && str[i] === '1'; i++) {
                    bytes.unshift(0);
                }

                console.log('Base58解码结果:', {
                    input: str,
                    outputLength: bytes.length,
                    firstByte: bytes[0]
                });

                return new Uint8Array(bytes);
            } catch (error) {
                console.error('Base58解码时出错:', error);
                return null;
            }
        }

        // 比较两个数组是否相等
        function arraysEqual(a, b) {
            if (a.length !== b.length) return false;
            for (let i = 0; i < a.length; i++) {
                if (a[i] !== b[i]) return false;
            }
            return true;
        }

        // 添加计算相似度的函数
        function calculateSimilarity(str1, str2) {
            let matches = 0;
            const minLength = Math.min(str1.length, str2.length);
            
            for (let i = 0; i < minLength; i++) {
                if (str1[i] === str2[i]) {
                    matches++;
                }
            }
            
            return matches / Math.max(str1.length, str2.length);
        }
    </script>
</body>
</html>
